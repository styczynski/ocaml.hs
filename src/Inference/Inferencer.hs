{-|
Module      : Inference.Inferencer
Description : Main code for type inference
Copyright   : (c) Piotr StyczyÅ„ski, 2019
License     : MIT
Maintainer  : piotr@styczynski.in
Stability   : experimental
Portability : POSIX

  This module provides basic code for translating simplified AST generated by
  Inference.Simplifier module, generating constraints on types and feeding them
  into Inference.ContraintSolver.
-}
module Inference.Inferencer where

import           Inference.Syntax
import           Inference.TypingEnvironment
import           Inference.Types
import           Inference.Substitutions
import           Inference.Errors
import           Inference.Simplifier
import           Inference.ConstraintSolver
import           Inference.InferencerUtils
import           Inference.TypeExpressionResolver

import           Syntax.Base             hiding ( TypeConstraint )
import qualified Syntax.Base                   as Syntax

import           Control.Monad.Except
import           Control.Monad.State
import           Control.Monad.Reader
import           Control.Monad.Identity
import           Data.Foldable

import           System.IO.Unsafe

import qualified Data.Map                      as Map
import qualified Data.Set                      as Set

-- | Runs inference monad
runInfer
  :: TypeEnvironment
  -> InferState
  -> Infer (TypeEnvironment, Type, [TypeConstraint])
  -> IO (Either TypeError ((TypeEnvironment, Type, [TypeConstraint]), InferState))
runInfer env state fn = do
  v <- runExceptT (runReaderT (runStateT fn (state)) (env))
  case v of
    (Left  e                   ) -> return $ Left e
    (Right ((env, t, c), state)) -> return $ Right ((env, t, c), state)

-- | Runs solver monad
solve
  :: Either TypeError (Type, [TypeConstraint]) -> IO (Either TypeError Scheme)
solve r = case r of
  Left  err      -> return $ Left err
  Right (ty, cs) -> do
    s <- runSolve cs
    case s of
      Left  err   -> return $ Left err
      Right subst -> return $ Right $ (normalize . generalize Inference.TypingEnvironment.empty) $ subst .> ty

-- | Helper to remove state and env from inference monad output
unpackEnvTypeContraints
  :: Either TypeError ((TypeEnvironment, Type, [TypeConstraint]), InferState)
  -> Either TypeError (Type, [TypeConstraint])
unpackEnvTypeContraints (Left  r             ) = Left r
unpackEnvTypeContraints (Right ((_, t, c), _)) = Right (t, c)

-- | Helper to extract environment from inference monad output
retrieveEnv
  :: Either TypeError ((TypeEnvironment, Type, [TypeConstraint]), InferState) -> TypeEnvironment
retrieveEnv (Left  r             ) = empty
retrieveEnv (Right ((e, _, _), _)) = e

-- | Helper to extract inferencer state from inference monad output
retrieveState
  :: Either TypeError ((TypeEnvironment, Type, [TypeConstraint]), InferState) -> InferState
retrieveState (Left  r         ) = initInfer
retrieveState (Right (_, state)) = state

-- | Takes AST and run inferencer and solver returning inferenced type
inferAST
  :: TypeEnvironment
  -> InferState
  -> Implementation
  -> IO (Either TypeError (Scheme, TypeEnvironment, InferState))
inferAST env state ex = do
  i      <- runInfer env state (inferImplementation ex)
  env    <- return $ retrieveEnv i
  state  <- return $ retrieveState i
  scheme <- solve $ unpackEnvTypeContraints i
  case scheme of
    Left  e -> return $ Left e
    Right s -> return $ Right (s, env, state)

-- | Get type contraints for given implementation node in AST
inferImplementation :: Implementation -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferImplementation ast@(IRoot cores) = do
  markTrace ast
  env <- ask
  r   <- foldlM
    (\(envAcc, _, _) core -> do
      i <- local (\_ -> envAcc) $ inferImplementationCore core
      return i
    )
    (env, TypeUnit, [])
    cores
  unmarkTrace ast
  return r

-- | Get type contraints for given implementation core node in AST
inferImplementationCore
  :: ImplementationCore -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferImplementationCore ast@(IRootExpr expr) = do
  markTrace ast
  env    <- ask
  (t, c) <- inferComplexExpression expr
  unmarkTrace ast
  return (env, t, c)
inferImplementationCore ast@(IRootDef phrases) = do
  markTrace ast
  env <- ask
  r   <- foldlM
    (\(envAcc, _, _) phrase -> do
      i <- local (\_ -> envAcc) $ inferImplementationPhrase phrase
      return i
    )
    (env, TypeUnit, [])
    phrases
  unmarkTrace ast
  return r

-- | Creates abstract type constructor for given name and parameters
createTypeExpressionAbstractArgConstructor
  :: Ident -> [String] -> TypeExpression
createTypeExpressionAbstractArgConstructor typeName [] =
  TypeExprSimple $ TypeSExprIdent $ typeName
createTypeExpressionAbstractArgConstructor typeName names@(hNames : tNames) =
  let
    (identHead : identTail) = map
      (\e ->
        TypeArgEl $ TypeExprSimple $ TypeSExprAbstract $ TypeIdentAbstract $ e
      )
      names
  in  TypeExprIdent (TypeArgJust identHead identTail) typeName

-- | Infers type for variant option
inferVariantOption
  :: [String] -> Ident -> TDefVariant -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferVariantOption typeVars typeName (TDefVarSimpl name@(Ident nameStr)) = do
  retType <- return
    $ createTypeExpressionAbstractArgConstructor typeName typeVars
  reverseType <- return $ TypeFun retType retType
  (r0, _, _)  <-
    inferImplementationPhrase
    $ IGlobalLet LetRecNo
                 (PatIdent $ Ident $ nameStr ++ "_reverse")
                 []
                 TypeConstrEmpty
    $ ECTyped reverseType
  r <-
    local (\_ -> r0)
    $ inferImplementationPhrase
    $ IGlobalLet LetRecNo (PatIdent name) [] TypeConstrEmpty
    $ ECTyped retType
  return r
inferVariantOption typeVars typeName (TDefVarCompl name@(Ident nameStr) typeExpr)
  = do
    fvsNames <- freeDimensionsM typeExpr
    payl     <- errPayload
    _        <- if fvsNames `Set.isSubsetOf` (Set.fromList typeVars)
      then return 0
      else
        throwError
        $ Debug payl
        $ "Invalid abstract variable used in type definition."
    -- [(PatCheck (Ident "x") typeExpr)]
    retType <- return
      $ createTypeExpressionAbstractArgConstructor typeName typeVars
    selType        <- return $ TypeFun (typeExpr) retType
    selReverseType <- return $ TypeFun retType (typeExpr)
    (r0, _, _)     <-
      inferImplementationPhrase
      $ IGlobalLet LetRecNo
                   (PatIdent $ Ident $ nameStr ++ "_reverse")
                   []
                   TypeConstrEmpty
      $ ECTyped selReverseType
    r <-
      local (\_ -> r0)
      $ inferImplementationPhrase
      $ IGlobalLet LetRecNo (PatIdent name) [] TypeConstrEmpty
      $ ECTyped selType
    return r

-- | Transforms AST type param to list of parameters' names
typeParamsToList :: TypeParam -> [String]
typeParamsToList TypeParamNone = []
typeParamsToList (TypeParamJust names) =
  map (\(TypeIdentAbstract name) -> name) names
typeParamsToList (TypeParamJustOne (TypeIdentAbstract name)) = [name]

------------------------------------------------------------------
--        Inference for various types of AST nodes              --
------------------------------------------------------------------

inferTypeDef :: TypeDef -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferTypeDef ast@(TypeDefVar typeParams name options) = do
  markTrace ast
  env <- ask
  r   <- foldlM
    (\(envAcc, _, _) option -> do
      i <- local (\_ -> envAcc)
        $ inferVariantOption (typeParamsToList typeParams) name option
      return i
    )
    (env, TypeUnit, [])
    options
  unmarkTrace ast
  return r
inferTypeDef ast@(TypeDefVarP typeParams name options) = do
  markTrace ast
  env <- ask
  r   <- foldlM
    (\(envAcc, _, _) option -> do
      i <- local (\_ -> envAcc)
        $ inferVariantOption (typeParamsToList typeParams) name option
      return i
    )
    (env, TypeUnit, [])
    options
  unmarkTrace ast
  return r

inferImplementationPhrase :: ImplPhrase -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferImplementationPhrase (IGlobalLetOperator recK opName restPatterns letExpr)
  = do
    (t, c) <- inferComplexExpression
      (ECLetOperator recK opName restPatterns letExpr $ ECExportEnv)
    return
      $ let (TypeAnnotated (AnnotationEnv exportedEnv)) = t
        in  (exportedEnv, t, c)
inferImplementationPhrase (IGlobalLet recK pattern restPatterns typeAnnot letExpr)
  = do
    (t, c) <- inferComplexExpression
      (ECLet recK pattern restPatterns typeAnnot letExpr $ ECExportEnv)
    return
      $ let (TypeAnnotated (AnnotationEnv exportedEnv)) = t
        in  (exportedEnv, t, c)
inferImplementationPhrase (IDefType typeDef) = inferTypeDef typeDef

inferComplexExpression :: ComplexExpression -> Infer (Type, [TypeConstraint])
inferComplexExpression ast = do
  tree <- simplifyComplexExpression resolveTypeExpression ast
  infer tree

inferE :: SimplifiedExpr -> Infer (TypeEnvironment, Type, [TypeConstraint])
inferE expr = do
  env    <- ask
  (t, c) <- infer expr
  return $ (env, t, c)

infer :: SimplifiedExpr -> Infer (Type, [TypeConstraint])
infer SimplifiedSkip            = return ((TypeStatic "Int"), [])
infer (SimplifiedConstInt    _) = return ((TypeStatic "Int"), [])
infer (SimplifiedConstBool   _) = return ((TypeStatic "Bool"), [])
infer (SimplifiedConstString _) = return ((TypeStatic "String"), [])
infer (SimplifiedAnnotated l t) = do
  s <- get
  put s { lastInferExpr = l }
  infer t
infer (SimplifiedTyped (Scheme _ t)) = return (t, [])
infer (SimplifiedExportEnv         ) = do
  env <- ask
  return (TypeAnnotated (AnnotationEnv env), [])
infer (SimplifiedCheck e (Scheme _ t)) = do
  (t1, c1) <- infer e
  ac       <- constraintAnnoTypeList [TypeConstraint EmptyPayload (t1, t)]
  return (t1, c1 ++ ac)
infer (SimplifiedVariable x) = do
  t <- lookupEnv x
  return (t, [])
infer (SimplifiedFunction x e) = do
  tv     <- freshTypeVar
  (t, c) <- (x, Scheme [] tv) ==> (infer e)
  return (tv `TypeArrow` t, c)
infer (SimplifiedCall e1 e2) = do
  (t1, c1) <- infer e1
  (t2, c2) <- infer e2
  tv       <- freshTypeVar
  ac       <- constraintAnnoTypeList
    [TypeConstraint EmptyPayload (t1, t2 `TypeArrow` tv)]
  return (tv, c1 ++ c2 ++ ac)
infer (SimplifiedLet x e1 e2) = do
  env      <- ask
  (t1, c1) <- infer e1
  s        <- lift $ lift $ lift $ runSolve c1
  case s of
    Left  err -> throwError err
    Right sub -> do
      let sc = generalize (sub .> env) (sub .> t1)
      (t2, c2) <- (x, sc) ==> (local (sub .>) (infer e2))
      return (t2, c1 ++ c2)
infer (SimplifiedFixPoint e1) = do
  (t1, c1) <- infer e1
  tv       <- freshTypeVar
  ac       <- constraintAnnoTypeList
    [TypeConstraint EmptyPayload (tv `TypeArrow` tv, t1)]
  return (tv, c1 ++ ac)
infer (SimplifiedUnaryOp (OpCustomUni name) e1) = do
  infer (SimplifiedCall (SimplifiedVariable $ Ident name) e1)
infer (SimplifiedUnaryOp op e1) = do
  (t1, c1) <- infer e1
  tv       <- freshTypeVar
  u1       <- return $ t1 `TypeArrow` tv
  u2       <- inferUnaryOperation op
  ac       <- constraintAnnoTypeList [TypeConstraint EmptyPayload (u1, u2)]
  return (tv, c1 ++ ac)
infer (SimplifiedBinaryOp (OpCustom name) e1 e2) = do
  infer
    (SimplifiedCall (SimplifiedCall (SimplifiedVariable $ Ident name) e1) e2)
infer (SimplifiedBinaryOp op e1 e2) = do
  (t1, c1) <- infer e1
  (t2, c2) <- infer e2
  tv       <- freshTypeVar
  u1       <- return $ t1 `TypeArrow` (t2 `TypeArrow` tv)
  u2       <- inferBinaryOperation op
  ac       <- constraintAnnoTypeList [TypeConstraint EmptyPayload (u1, u2)]
  return (tv, c1 ++ c2 ++ ac)
infer (SimplifiedIf cond tr fl) = do
  (t1, c1) <- infer cond
  (t2, c2) <- infer tr
  (t3, c3) <- infer fl
  ac       <- constraintAnnoTypeList
    [ (TypeConstraint EmptyPayload (t1, TypeStatic "Bool"))
    , (TypeConstraint EmptyPayload (t2, t3))
    ]
  return (t2, c1 ++ c2 ++ c3 ++ ac)

inferBinaryOperation :: BinaryOp -> Infer Type
inferBinaryOperation OpSemicolon = do
  tv1 <- freshTypeVar
  tv2 <- freshTypeVar
  return $ tv1 `TypeArrow` (tv2 `TypeArrow` tv2)
inferBinaryOperation OpSame = do
  tv <- freshTypeVar
  return $ tv `TypeArrow` (tv `TypeArrow` tv)
inferBinaryOperation OpCons = do
  tv <- freshTypeVar
  return $ (tv) `TypeArrow` ((TypeList tv) `TypeArrow` (TypeList tv))
inferBinaryOperation OpTupleCons = do
  tv  <- freshTypeVar
  tv2 <- freshTypeVar
  tv3 <- freshTypeVar
  return
    $           (tv)
    `TypeArrow` (           (TypeTuple tv2 tv3)
                `TypeArrow` (TypeTuple tv (TypeTuple tv2 tv3))
                )

inferUnaryOperation :: UnaryOp -> Infer Type
inferUnaryOperation OpHead = do
  tv <- freshTypeVar
  return $ (TypeList tv) `TypeArrow` (tv)
inferUnaryOperation OpTails = do
  tv <- freshTypeVar
  return $ (TypeList tv) `TypeArrow` (TypeList tv)
inferUnaryOperation OpEmptyList = do
  tv  <- freshTypeVar
  tv2 <- freshTypeVar
  return $ tv `TypeArrow` (TypeList tv2)
inferUnaryOperation OpEmptyTuple = do
  tv <- freshTypeVar
  return $ tv `TypeArrow` (TypeTuple TypeUnit TypeUnit)
inferUnaryOperation OpListNth = do
  tv <- freshTypeVar
  return $ (TypeList tv) `TypeArrow` tv
inferUnaryOperation (OpTupleNth index len) = do
  (tupleType, elsTypes) <- foldrM
    (\_ (tup, tvs) -> do
      tv <- freshTypeVar
      return $ ((TypeTuple tv tup), [tv] ++ tvs)
    )
    ((TypeTuple TypeUnit TypeUnit), [])
    (replicate len 0)
  return $ (tupleType) `TypeArrow` (elsTypes !! index)
