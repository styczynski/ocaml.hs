implementation ::= { impl-phrase ;;}

impl-phrase ::= expression | value-definition | type-definition

value-definition ::= let [ rec ] let-binding { and let-binding }

let-binding ::= pattern = expression | variable pattern-list = expression

interface  ::= { intf-phrase ;; }

value-declaration  ::= value ident : type-expression {  and ident : type-expression }

expression  ::= 
       primary-expression
     | construction-expression
     | nary-expression
     | sequencing-expression

primary-expression  ::=  
       ident
    |  variable
    |  constant
    |  ( expression )
    |  begin expression end
    |  ( expression : type-expression )

construction-expression  ::= 
       ncconstr expression
    |  expression , expression { , expression } 
    |  expression :: expression
    |  [ expression { ;  expression }  ]
    |  [| expression { ; expression }  |]
    |  { label = expression { ; label = expression } }
    |  function simple-matching
    |  fun multiple-matching

nary-expression  ::=  
        expression expression
     |  prefix-op expression     |  expression infix-op expression
     |  expression && expression  |  expression || expression
     |  expression . label       |  expression . label <- expression
     |  expression .( expression )  |  expression .( expression ) <- expression
     |  expression .[ expression ]  |  expression .[ expression ] <- expression

sequencing-expression  ::=  
        expression ; expression
     |  if expression then expression [  else expression ]
     |  match expression with simple-matching
     |  while expression do expression done
     |  for ident = expression (  to |  downto ) expression do expression done
     |  let [ rec ]  let-binding  { and let-binding }  in expression

simple-matching  ::=  
    pattern -> expression { | pattern -> expression } 

multiple-matching  ::=  
    pattern-list -> expression { | pattern-list -> expression } 

pattern-list  ::=  
    pattern {  pattern } 

prefix-op  ::=  
     - | -. | !

infix-op  ::=  
    + | -  | * | / |  mod | +. | -. | *. | /. | @ | ^ | !  |  := |  
  | = | <> | == | != | < | <= | > | <= | <. | <=. | >. | <=.

pattern  ::=  
        ident
     |  constant
     |  ( pattern )
     |  ( pattern : type-expression )
     |  ncconstr pattern
     |  pattern , pattern { , pattern } 
     |  pattern :: pattern
     |  [ pattern { ; pattern }  ]
     |  { label = pattern { ; label = pattern } }
     |  pattern | pattern
     |  _
     |  pattern as ident

type-definition  ::=  
        type typedef {  and typedef } 

typedef  ::=  
        type-params ident = constr-decl {| constr-decl } 
     |  type-params ident = { label-decl { ; label-decl } }
     |  type-params ident == type-expression
     |  type-params ident

type-params  ::=  
        nothing
     |  ' ident
     |  ( ' ident { , ' ident } )

constr-decl  ::=  
        ident
     |  ident of type-expression

label-decl  ::=  
        ident : type-expression

type-expression  ::=  
       ' ident
     |  ( type-expression )
     |  type-expression -> type-expression
     |  type-expression {* type-expression }
     |  typeconstr
     |  type-expression typeconstr
     |  ( type-expression { , type-expression } ) typeconstr

constant  ::=  
       integer-literal
     |  float-literal
     |  char-literal
     |  string-literal
     |  cconstr

global-name  ::=  
        ident
     |  ident__ident

variable  ::=  
        global-name
     |  prefix operator-name

operator-name  ::=  
       + | -  | * | / |  mod | +. | -. | *. | /. 
     | @ | ^ | ! | := | = | <> | == | != 
     | < | <= | > | <. | <=. | >. | <=.

cconstr  ::=  
        global-name
     |  []
     |  ()

ncconstr  ::=  
        global-name
      |  prefix ::

typeconstr  ::=  
        global-name

label  ::=  
        global-name
